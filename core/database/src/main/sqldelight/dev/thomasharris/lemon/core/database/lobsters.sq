import kotlin.Boolean;
import kotlin.Int;
import kotlin.String;
import kotlin.collections.List;
import kotlinx.datetime.Instant;

CREATE TABLE story (
    shortId TEXT NOT NULL UNIQUE PRIMARY KEY,
    title TEXT NOT NULL,
    createdAt INTEGER AS Instant NOT NULL,
    url TEXT NOT NULL,
    score INTEGER AS Int NOT NULL,
    commentCount INTEGER AS Int NOT NULL,
    description TEXT NOT NULL,
    username TEXT NOT NULL,
    tags TEXT AS List<String> NOT NULL,
    pageIndex INTEGER AS Int,
    pageSubIndex INTEGER AS Int,
    insertedAt INTEGER AS Instant NOT NULL
);

CREATE TABLE user (
    username TEXT NOT NULL UNIQUE PRIMARY KEY,
    createdAt INTEGER AS Instant NOT NULL,
    isAdmin INTEGER AS Boolean NOT NULL,
    about TEXT NOT NULL,
    isModerator INTEGER AS Boolean NOT NULL,
    karma INTEGER AS Int NOT NULL,
    avatarShortUrl TEXT NOT NULL,
    invitedByUser TEXT,
    insertedAt INTEGER AS Instant NOT NULL,
    githubUsername TEXT,
    twitterUsername TEXT
);

-- add a field pointing to sibling to make collapsing easier?
CREATE TABLE comment (
    shortId TEXT NOT NULL UNIQUE PRIMARY KEY,
    storyId TEXT NOT NULL,
    commentIndex INTEGER AS Int NOT NULL,
    createdAt INTEGER AS Instant NOT NULL,
    updatedAt INTEGER AS Instant NOT NULL,
    isDeleted INTEGER AS Boolean NOT NULL,
    isModerated INTEGER AS Boolean NOT NULL,
    score INTEGER AS Int NOT NULL,
    comment TEXT NOT NULL,
    indentLevel INTEGER AS Int NOT NULL,
    username TEXT NOT NULL,
    insertedAt INTEGER AS Instant NOT NULL
--     status INTEGER AS CommentStatus NOT NULL
);

countStoriesOnFrontPage:
SELECT
    count(*)
FROM story
WHERE pageIndex IS NOT NULL;

getStoriesOnFrontPage:
SELECT *
FROM story
WHERE pageIndex IS NOT NULL
LIMIT :limit
OFFSET :offset;

getStoriesOnFrontPageWithUsers:
SELECT
    s.shortId,
    s.createdAt,
    s.title,
    s.url,
    s.score,
    s.commentCount,
    s.description,
    s.tags,
    u.username,
    u.createdAt userCreatedAt,
    u.isAdmin,
    u.about,
    u.isModerator,
    u.karma,
    u.avatarShortUrl,
    u.invitedByUser,
    u.githubUsername,
    u.twitterUsername
FROM story s
JOIN user u
ON s.username = u.username
WHERE pageIndex IS NOT NULL
ORDER BY s.pageIndex, s.pageSubIndex
LIMIT :limit
OFFSET :offset;

getStoryWithUser:
SELECT
    s.shortId,
    s.createdAt,
    s.title,
    s.url,
    s.score,
    s.commentCount,
    s.description,
    s.tags,
    u.username,
    u.createdAt userCreatedAt,
    u.isAdmin,
    u.about,
    u.isModerator,
    u.karma,
    u.avatarShortUrl,
    u.invitedByUser,
    u.githubUsername,
    u.twitterUsername
FROM story s
JOIN user u
ON s.username = u.username
WHERE s.shortId = :storyId;

getOldestStory:
SELECT min(insertedAt) FROM story;

getStory:
SELECT
    *
FROM story
WHERE shortId = :shortId;

insertStory:
INSERT OR REPLACE INTO story VALUES ?;

deleteStories:
DELETE FROM story;

getUsers:
SELECT * FROM user;

getComments:
SELECT * FROM comment;

-- user queries
insertUser:
INSERT OR REPLACE INTO user VALUES ?;

-- comment queries
insertComment:
INSERT OR REPLACE INTO comment VALUES ?;

getCommentsWithUserByStoryId:
SELECT
    c.shortId,
    c.storyId,
    c.createdAt,
    c.updatedAt,
    c.isDeleted,
    c.isModerated,
    c.score,
    c.comment,
    c.indentLevel,
    u.username,
    u.createdAt userCreatedAt,
    u.isAdmin,
    u.about,
    u.isModerator,
    u.karma,
    u.avatarShortUrl,
    u.invitedByUser,
    u.githubUsername,
    u.twitterUsername
FROM comment c
JOIN user u
ON c.username = u.username
WHERE storyId = :storyId
ORDER BY commentIndex ASC
LIMIT :limit
OFFSET :offset;

getOldestComment:
SELECT
    min(insertedAt)
FROM comment
WHERE storyId = :storyId;

deleteCommentsWithStoryId:
DELETE FROM comment
WHERE storyId = :storyId;

countCommentsWithStoryId:
SELECT
    count(*)
FROM comment
WHERE storyId = :storyId;